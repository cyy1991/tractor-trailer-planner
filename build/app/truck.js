// Generated by CoffeeScript 1.6.2
(function() {
  var tractor, trailer, trailer2;

  window.truck = {
    L: config.truck.tractor.length() * config.scale,
    L1: config.truck.trailer.length() * config.scale,
    W: config.truck.tractor.width() * config.scale,
    U_PHI_MAX: [-config.steer(), config.steer()],
    U_S_MAX: [-config.speed(), 0, config.speed()],
    conf: new Conf(center.x, center.y, center.theta, center.theta, 0, 0, center.theta),
    dirty: true,
    ctx: ctxTruck,
    update: function() {
      var conf;

      conf = sensorSystem.conf;
      this.conf.phi = -conf.phi;
      this.conf.s = conf.s;
      if (sensorSystem.angle === this.conf.theta1) {
        return;
      }
      this.dirty = true;
      this.conf.theta1 = sensorSystem.angle;
      return this.conf.theta2 = sensorSystem.angle2;
    },
    draw: function() {
      if (!this.dirty) {
        return;
      }
      this.dirty = false;
      return renderCar3d(this.ctx, this.conf);
    },
    step: function(x, y, theta, theta1, u_s, u_phi, runs, theta2) {
      if (u_s == null) {
        u_s = 1;
      }
      if (u_phi == null) {
        u_phi = 0;
      }
      if (runs == null) {
        runs = 1;
      }
      while (runs-- > 0 && absDiff(theta, theta1) <= PIHALF) {
        x += u_s * Math.cos(theta);
        y += u_s * Math.sin(theta);
        theta += (u_s / this.L) * Math.tan(u_phi);
        theta1 += (u_s / this.L1) * Math.sin(theta - theta1);
        theta2 += (u_s / this.L1) * Math.cos(theta - theta1) * Math.sin(theta1 - theta2);
      }
      theta %= PI2;
      if (theta > 0) {
        theta -= PI2;
      }
      theta1 %= PI2;
      if (theta1 > 0) {
        theta1 -= PI2;
      }
      theta2 %= PI2;
      if (theta2 > 0) {
        theta2 -= PI2;
      }
      return {
        x: Math.round(x),
        y: Math.round(y),
        theta: theta,
        theta1: theta1,
        theta2: theta2,
        s: u_s,
        phi: u_phi
      };
    },
    outlines: function(conf) {
      var anglePoint, tractor, trailer, trailer2, trailerArrow;

      tractor = rotateRect(conf.theta, conf.x, conf.y, this.L, this.W);
      trailer = rotateRect(conf.theta1, conf.x, conf.y, -this.L1, this.W);
      anglePoint = rotateRect(conf.theta1, conf.x, conf.y, -this.L1, 0);
      trailer2 = rotateRect(conf.theta2, anglePoint[1][0], anglePoint[1][1], -this.L1, this.W);
      trailerArrow = rotateRect(conf.theta1, conf.x, conf.y, this.L - 5, this.W);
      return tractor.concat(trailerArrow, trailer, trailer2);
    },
    legalMoves: function(conf, borders, repeatStep, directions, steers) {
      var direction, length, nextConf, outlines, ret, steer, _i, _j, _len, _len1;

      if (borders == null) {
        borders = [];
      }
      if (repeatStep == null) {
        repeatStep = config.steps();
      }
      if (directions == null) {
        directions = [config.direction(), -config.direction()];
      }
      if (steers == null) {
        steers = [-config.steer(), 0, config.steer()];
      }
      ret = [];
      for (_i = 0, _len = directions.length; _i < _len; _i++) {
        direction = directions[_i];
        for (_j = 0, _len1 = steers.length; _j < _len1; _j++) {
          steer = steers[_j];
          nextConf = this.step(conf.x, conf.y, conf.theta, conf.theta1, direction, steer, repeatStep, conf.theta2);
          if (absDiff(nextConf.theta, nextConf.theta1) <= PIHALF) {
            if (borders.length > 0) {
              outlines = this.outlines(nextConf);
            } else {
              outlines = [];
            }
            length = outlines.length - 1;
            if (this.validMove(conf, borders, outlines, length)) {
              ret.push(nextConf);
            }
          }
        }
      }
      return ret;
    },
    validMove: function(conf, borders, outlines, length) {
      var b, i, _i, _len;

      for (_i = 0, _len = borders.length; _i < _len; _i++) {
        b = borders[_i];
        i = 0;
        while (i < length) {
          if (i === 3) {
            i++;
          }
          if (lineSegmentIntersect(outlines[i], outlines[++i], b[0], b[1])) {
            return false;
          }
        }
      }
      return true;
    }
  };

  tractor = new Image();

  trailer = new Image();

  trailer2 = new Image();

  tractor.src = '/images/tractor.png';

  trailer.src = '/images/trailer.png';

  trailer2.src = '/images/trailer2.png';

  tractor.onload = function() {
    return truck.dirty = true;
  };

  trailer.onload = function() {
    return truck.dirty = true;
  };

  trailer2.onload = function() {
    return truck.dirty = true;
  };

  window.renderCar = function(ctx, conf) {
    var i, outlines;

    outlines = truck.outlines(conf);
    i = 0;
    while (i < outlines.length - 1) {
      if (i === 3 || i === 11) {
        i++;
      }
      ctx.moveTo(outlines[i][0], outlines[i][1]);
      ctx.lineTo(outlines[++i][0], outlines[i][1]);
    }
    return ctx.moveTo(conf.x, conf.y);
  };

  window.renderCar3d = function(ctx, conf) {
    var pos;

    pos = {
      x: conf.x - center.x,
      y: conf.y - center.y
    };
    ctx.clearRect(120, 300, 540, 330);
    ctx.save();
    ctx.translate(center.x, center.y);
    ctx.save();
    ctx.rotate(conf.theta);
    ctx.drawImage(tractor, pos.x - truck.L / 2, pos.y - truck.W / 2);
    ctx.restore();
    ctx.save();
    ctx.rotate(conf.theta1);
    ctx.drawImage(trailer, pos.x - truck.L1 + truck.L / 14, pos.y - truck.W / 2);
    ctx.translate(-truck.L1, 0);
    ctx.rotate(-conf.theta1 + conf.theta2);
    ctx.fillRect(-truck.L1, 0, truck.L1, 2);
    ctx.drawImage(trailer2, -truck.L1, -truck.W / 2);
    ctx.restore();
    return ctx.restore();
  };

}).call(this);
