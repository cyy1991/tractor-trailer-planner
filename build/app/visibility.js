// Generated by CoffeeScript 1.6.2
(function() {
  var blocks, computeVisibleAreaPaths, drawFloor, drawFloorTriangles, drawUnknownBorders, drawWalls, formatWall, g, gridMargin, interpretSvg, intersectWithAxis, size, svgToCoords, visibility, walls;

  size = 800;

  gridMargin = 0;

  blocks = [];

  walls = [];

  g = cnvs.append('visibility', document.getElementById('container'), size, size);

  window.visib = g;

  interpretSvg = function(g, path) {
    var i, _results;

    i = 0;
    _results = [];
    while (i < path.length) {
      if (path[i] === "M") {
        g.moveTo(path[i + 1], path[i + 2]);
        i += 2;
      }
      if (path[i] === "L") {
        g.lineTo(path[i + 1], path[i + 2]);
        i += 2;
      }
      _results.push(i++);
    }
    return _results;
  };

  svgToCoords = function(path) {
    var i, _i, _ref, _results;

    _results = [];
    for (i = _i = 0, _ref = path.length; _i < _ref; i = _i += 6) {
      _results.push([
        {
          x: path[i + 1],
          y: path[i + 2]
        }, {
          x: path[i + 4],
          y: path[i + 5]
        }
      ]);
    }
    return _results;
  };

  computeVisibleAreaPaths = function(center, output) {
    var i, inter, p, p1, p2, path1, path2, path3, path4, _i, _len, _ref;

    path1 = [];
    path2 = [];
    path3 = [];
    path4 = [];
    i = 0;
    while (i < output.length) {
      p1 = output[i];
      p2 = output[i + 1];
      if (isNaN(p1.x) || isNaN(p1.y) || isNaN(p2.x) || isNaN(p2.y)) {
        continue;
      }
      path1.push("L", p1.x, p1.y, "L", p2.x, p2.y);
      path2.push("M", center.x, center.y, "L", p1.x, p1.y, "M", center.x, center.y, "L", p2.x, p2.y);
      path3.push("M", p1.x, p1.y, "L", p2.x, p2.y);
      _ref = [p1, p2];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        p = _ref[_i];
        inter = intersectWithAxis(g, center, {
          x: p.x,
          y: p.y
        }, size);
        path4.push("M", p.x, p.y, "L", inter.x, inter.y);
      }
      i += 2;
    }
    return {
      floor: path1,
      triangles: path2,
      walls: path3,
      unknown: path4
    };
  };

  drawFloorTriangles = function(g, path) {
    g.save();
    g.strokeStyle = "hsl(80, 30%, 25%)";
    g.beginPath();
    interpretSvg(g, path);
    g.stroke();
    return g.restore();
  };

  intersectWithAxis = function(g, p1, p2, size) {
    var h, hp3, hp4, v, vp3, vp4, _ref;

    if (p2.x < p1.x) {
      vp3 = {
        x: 0,
        y: 0
      };
      vp4 = {
        x: 0,
        y: 1
      };
    } else {
      vp3 = {
        x: size,
        y: 0
      };
      vp4 = {
        x: size,
        y: 1
      };
    }
    if (p2.y < p1.y) {
      hp3 = {
        x: 0,
        y: 0
      };
      hp4 = {
        x: 1,
        y: 0
      };
    } else {
      hp3 = {
        x: 0,
        y: size
      };
      hp4 = {
        x: 1,
        y: size
      };
    }
    v = visibility.lineIntersection(p1, p2, vp3, vp4);
    h = visibility.lineIntersection(p1, p2, hp3, hp4);
    if ((0 <= (_ref = v.x) && _ref <= size)) {
      return v;
    } else {
      return h;
    }
  };

  drawUnknownBorders = function(g, path) {
    g.save();
    g.strokeStyle = "hsl(60, 100%, 40%)";
    g.beginPath();
    interpretSvg(g, path);
    g.stroke();
    return g.restore();
  };

  drawFloor = function(g, path, solidStyle) {
    var gradient;

    if (solidStyle == null) {
      solidStyle = false;
    }
    g.save();
    g.fillStyle = 'hsl(210, 50%, 25%)';
    g.fillRect(0, 0, size, size);
    if (solidStyle) {
      g.fillStyle = "hsla(60, 75%, 60%, 0.2)";
    } else {
      gradient = g.createRadialGradient(center.x, center.y, 0, center.x, center.y, size * 0.75);
      gradient.addColorStop(0.0, "hsla(60, 100%, 75%, 0.6)");
      gradient.addColorStop(0.5, "hsla(60, 50%, 50%, 0.4)");
      gradient.addColorStop(1.0, "hsla(60, 60%, 30%, 0.2)");
      g.fillStyle = gradient;
    }
    g.beginPath();
    g.moveTo(center.x, center.y);
    interpretSvg(g, path);
    g.lineTo(center.x, center.y);
    g.fill();
    return g.restore();
  };

  drawWalls = function(g, path) {
    g.save();
    g.strokeStyle = "hsl(60, 100%, 90%)";
    g.lineWidth = 5;
    g.beginPath();
    interpretSvg(g, path);
    g.stroke();
    return g.restore();
  };

  visibility = new Visibility();

  window.shadows = {
    update: function() {
      var borders, paths;

      visibility.loadMap(size, gridMargin, [], edgeDetection.walls.map(formatWall));
      visibility.setLightLocation(center.x, center.y);
      visibility.sweep(Math.PI);
      paths = computeVisibleAreaPaths(center, visibility.output);
      borders = paths.walls;
      if ((typeof treatUnknownAsBorder !== "undefined" && treatUnknownAsBorder !== null)) {
        borders = borders.concat(paths.unknown);
      }
      return app.trigger('visibilityDetected.lidar', [svgToCoords(borders)]);
    },
    draw: function() {
      g.clearRect(0, 0, size, size);
      drawFloor(g, paths.floor);
      return drawWalls(g, paths.walls);
    }
  };

  formatWall = function(wall) {
    if (!(wall.length > 0)) {
      return;
    }
    return {
      p1: {
        x: wall[0][0],
        y: wall[0][1]
      },
      p2: {
        x: wall[1][0],
        y: wall[1][1]
      }
    };
  };

}).call(this);
