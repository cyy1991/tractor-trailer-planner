// Generated by CoffeeScript 1.6.2
(function() {
  var bresenhamLine, config, detectWalls, distance, free, getBorderPoints, isFree, isWebWorker, maxDistance, maxDistanceToLine, minLength, raytrace, require, samplePoints, slope, update;

  isWebWorker = false;

  if (typeof window === 'undefined') {
    isWebWorker = true;
    self.window = self;
    self.ko = {
      observable: function(e) {
        return e;
      }
    };
    config = {
      raytraceAngles: function() {
        return ko.observable(200);
      },
      wallNumber: function() {
        return ko.observable(0);
      },
      ed: {
        maxDistance: function() {
          return ko.observable(60);
        },
        maxDistanceToLine: function() {
          return ko.observable(4);
        },
        minLength: function() {
          return ko.observable(3);
        },
        minR2: function() {
          return ko.observable(0.63);
        },
        frequency: function() {
          return ko.observable(150);
        }
      }
    };
    require = function(name) {
      return importScripts("/build/" + name + ".js");
    };
    require('helper/helpers');
  } else {
    config = window.config;
  }

  free = [(223 | 219 << 8 | 212 << 16 | 255 << 24) >>> 0, (201 | 223 << 8 | 175 << 16 | 255 << 24) >>> 0, (232 | 221 << 8 | 189 << 16 | 255 << 24) >>> 0, 255, 0];

  getBorderPoints = function(n, width, height) {
    var circumference, distance, i, points, pos, _i;

    points = [];
    pos = 0;
    circumference = 2 * (width + height);
    distance = circumference / n;
    for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
      if (pos < width) {
        points.push([pos, 0]);
      } else if (pos < width + height) {
        points.push([width, pos - width]);
      } else if (pos < 2 * width + height) {
        points.push([width - pos + width + height, height]);
      } else {
        points.push([0, height - pos + 2 * width + height]);
      }
      pos += distance;
    }
    return points;
  };

  isFree = function(x, y, data, width) {
    var f, offset, _i, _len;

    offset = width * y + x;
    for (_i = 0, _len = free.length; _i < _len; _i++) {
      f = free[_i];
      if (f === data[offset]) {
        return true;
      }
    }
    return false;
  };

  bresenhamLine = function(x0, y0, x1, y1, callback, data, width) {
    var dx, dy, e2, err, success, sx, sy;

    dx = Math.abs(x1 - x0);
    dy = Math.abs(y1 - y0);
    sx = (x0 < x1 ? 1 : -1);
    sy = (y0 < y1 ? 1 : -1);
    err = dx - dy;
    while (true) {
      success = callback(x0, y0, data, width);
      if (!success || ((x0 === x1) && (y0 === y1))) {
        return [x0, y0];
      }
      e2 = 2 * err;
      if (e2 > -dy) {
        err -= dy;
        x0 += sx;
      }
      if (e2 < dx) {
        err += dx;
        y0 += sy;
      }
    }
  };

  slope = function(p, q) {
    var s;

    s = p[0] - q[0];
    if (isNaN(s)) {
      return 0;
    } else {
      return Number(((p[1] - q[1]) / s).toFixed(2));
    }
  };

  distance = function(p, q) {
    return Math.pow(p[0] - q[0], 2) + Math.pow(p[1] - q[1], 2);
  };

  window.nearerThan = function(p, q, maxDistance) {
    return distance(p, q) <= maxDistance;
  };

  window.linearRegression = function(points) {
    var dividend, divisor, i, lr, n, sum_x, sum_xx, sum_xy, sum_y, sum_yy, x, y;

    x = points.map(function(e) {
      return e[0];
    });
    y = points.map(function(e) {
      return e[1];
    });
    lr = {};
    n = y.length;
    sum_x = 0;
    sum_y = 0;
    sum_xy = 0;
    sum_xx = 0;
    sum_yy = 0;
    i = 0;
    while (i < y.length) {
      sum_x += x[i];
      sum_y += y[i];
      sum_xy += x[i] * y[i];
      sum_xx += x[i] * x[i];
      sum_yy += y[i] * y[i];
      i++;
    }
    lr.slope = (n * sum_xy - sum_x * sum_y) / (n * sum_xx - sum_x * sum_x);
    lr.intercept = (sum_y - lr.slope * sum_x) / n;
    dividend = n * sum_xy - sum_x * sum_y;
    divisor = Math.sqrt((n * sum_xx - sum_x * sum_x) * (n * sum_yy - sum_y * sum_y));
    if (divisor === dividend) {
      lr.r2 = 1;
    } else {
      lr.r2 = Math.pow(dividend / divisor, 2);
    }
    lr.vertical = isNaN(lr.slope);
    if (lr.vertical) {
      lr.intercept = x[0];
      lr.slope = 0;
    }
    return lr;
  };

  raytrace = function(imageData, x, y, width, height) {
    var i, maxDistance, maxSlopeDiff, newPoint, numAngles, p, points, _i, _len, _ref, _ref1, _ref2;

    numAngles = config.raytraceAngles();
    maxDistance = Math.pow(50, 2);
    maxSlopeDiff = 0.1;
    points = [];
    _ref = getBorderPoints(numAngles, width, height);
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      p = _ref[i];
      newPoint = bresenhamLine(x, y, p[0], p[1], isFree, imageData, width);
      if (((_ref1 = newPoint[0]) === p[0] || _ref1 === 0) || ((_ref2 = newPoint[1]) === p[1] || _ref2 === 0)) {
        continue;
      }
      points.push(newPoint);
    }
    return points;
  };

  detectWalls = function(points, minLength, maxDistanceToLine, maxDistance) {
    var error, firstPoint, i, lastPoint, near, p, sample, wall, walls;

    i = 0;
    walls = [];
    while (i < points.length) {
      sample = samplePoints(points.slice(i), minLength, maxDistance);
      if (sample == null) {
        return;
      }
      i += sample.index + sample.size;
      wall = [points[i - sample.size], points[i - 1]];
      while (i < points.length) {
        p = points[i];
        near = nearerThan(wall[1], p, maxDistance);
        error = distanceToLine(p, sample.slope, sample.intercept, sample.vertical);
        if (near && (error < maxDistanceToLine)) {
          wall[1] = p;
          i++;
        } else {
          if (near) {
            i--;
          }
          break;
        }
      }
      walls.push(wall);
    }
    if (walls.length > 1) {
      firstPoint = walls[0][0];
      lastPoint = walls.last()[1];
      near = nearerThan(firstPoint, lastPoint, maxDistance);
      error = distanceToLine(firstPoint, sample.slope, sample.intercept, sample.vertical);
      if (near && (error < maxDistanceToLine)) {
        walls[0][0] = walls.pop()[0];
      }
    }
    config.wallNumber(walls.length);
    return walls;
  };

  samplePoints = function(points, minLength, maxDistance) {
    var i, lr, minR2, slice;

    minR2 = config.ed.minR2();
    i = 0;
    while (i < points.length) {
      slice = points.slice(i, minLength + i++);
      if (!slice.every(function(e, j, slice) {
        if (j === 0 || nearerThan(slice[j - 1], e, maxDistance)) {
          return true;
        }
      })) {
        continue;
      }
      lr = linearRegression(slice);
      if (lr.r2 >= minR2) {
        lr.index = i - 1;
        lr.size = slice.length;
        return lr;
      }
    }
  };

  window.distanceToLine = function(p, slope, intercept, vertical) {
    var a0, b0, px, py, x, y;

    if (vertical) {
      y = p[0], x = p[1];
    } else {
      x = p[0], y = p[1];
    }
    if (slope === 0) {
      return distance([x, y], [x, intercept]);
    }
    a0 = -1 / slope;
    b0 = y - a0 * x;
    px = (intercept - b0) / (a0 - slope);
    py = (a0 * (intercept - b0)) / (a0 - slope) + b0;
    return distance(p, [px, py]);
  };

  minLength = Number(config.ed.minLength());

  maxDistanceToLine = Math.pow(config.ed.maxDistanceToLine(), 2);

  maxDistance = Math.pow(config.ed.maxDistance(), 2);

  update = function(imageData, cb) {
    var points, walls;

    points = raytrace(imageData, 400, 400, 800, 800);
    walls = detectWalls(points, minLength, maxDistanceToLine, maxDistance);
    if (walls.length > 0) {
      return cb(walls);
    }
  };

  if (isWebWorker) {
    self.addEventListener('message', function(e) {
      return update(e.data.imageData, function(walls) {
        return self.postMessage({
          walls: walls
        });
      });
    }, false);
  } else {
    if (typeof edgeDetection !== 'undefined') {
      edgeDetection.walls = walls;
    }
  }

}).call(this);
