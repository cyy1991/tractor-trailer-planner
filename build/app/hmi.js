// Generated by CoffeeScript 1.6.2
(function() {
  var MODE_GOAL, MODE_OBS, canvas, ctxBuffer, ctxDraft, endDrag, mode, startDrag, updateDrag;

  ctxDraft = cnvs.append('draft', container, config.canvasWidth, config.canvasHeight);

  ctxBuffer = cnvs.create(config.canvasWidth, config.canvasHeight);

  window.relativeToAbsolute = function(p) {
    var c, px, py, s, x, y;

    x = p.x - center.x;
    y = p.y - center.y;
    s = Math.sin(delta.theta);
    c = Math.cos(delta.theta);
    px = (x * c + y * s) + delta.x + center.x;
    py = (x * -s + y * c) + delta.y + center.y;
    return new Conf(px, py, p.theta - delta.theta, p.theta1 - delta.theta, p.s, p.phi, p.theta2 - delta.theta);
  };

  window.absoluteToRelative = function(p) {
    var c, px, py, s, x, y;

    x = p.x + delta.x + center.x;
    y = p.y + delta.y + center.y;
    s = Math.sin(delta.theta);
    c = Math.cos(delta.theta);
    px = (x * c + y * s) + delta.x + center.x;
    py = (x * -s + y * c) + delta.y + center.y;
    return new Conf(x, y, -PIHALF, p.theta1 + center.theta + delta.theta);
  };

  window.joystick = {
    conf: {
      phi: 0,
      s: 0,
      u_s: 0,
      u_phi: 0
    },
    maxSteps: 10,
    dirty: true,
    ctx: ctxInput,
    ctxBuffer: cnvs.create(800, 800),
    imgIs: new Image(),
    imgShould: new Image(),
    init: function() {
      this.imgIs.src = '/images/joystick-is.png';
      return this.imgShould.src = '/images/joystick-should.png';
    },
    setConf: function(conf) {
      if (conf) {
        this.conf.phi = conf.phi;
        this.conf.s = conf.s;
      } else {
        this.conf.s = 0;
      }
      return this.dirty = true;
    },
    update: function() {
      var absoluteConfig;

      if (!waypoints.isActive()) {
        return;
      }
      absoluteConfig = relativeToAbsolute(truck.conf);
      if (equals(absoluteConfig, waypoints.current(), 200, 0.2)) {
        if (equals(absoluteConfig, waypoints.path.last(), 1000, 0.2)) {
          waypoints.init();
        } else {
          waypoints.next();
        }
      }
      if (waypoints.current()) {
        return this.setConf(waypoints.current());
      } else {
        this.setConf(this.conf.phi = 0);
        this.setConf(this.conf.s = 0);
        return waypoints.init();
      }
    },
    draw: function() {
      var margin, size;

      size = 367;
      margin = 450;
      this.ctxBuffer.clearRect(margin - 1, margin - 1, size + 1, size / 2);
      if (this.conf.s !== 0) {
        this.drawJoystick(this.conf.phi, this.conf.s, true);
      }
      return this.drawJoystick(-window.u_phi, window.u_s);
    },
    drawJoystick: function(phi, s, wanted) {
      var img, margin, size, steeringPercent;

      if (wanted == null) {
        wanted = false;
      }
      size = 367;
      margin = 450;
      steeringPercent = phi / truck.U_PHI_MAX[1];
      this.ctxBuffer.save();
      this.ctxBuffer.translate(size / 2 + margin, size / 2 + margin);
      this.ctxBuffer.rotate(phi);
      this.ctxBuffer.translate(-size / 2, -size / 2);
      img = wanted ? this.imgShould : this.imgIs;
      this.ctxBuffer.drawImage(img, 0, 0);
      this.ctxBuffer.restore();
      this.ctx.clearRect(margin - 1, margin - 1, size + 1, size / 2);
      return this.ctx.drawImage(this.ctxBuffer.canvas, 0, 0);
    }
  };

  joystick.init();

  window.waypoints = {
    path: [],
    cursor: 0,
    ctx: ctxPath,
    running: false,
    init: function(path, goal) {
      var avg, i, length, p, _i, _len;

      if (path == null) {
        path = [];
      }
      if (goal == null) {
        goal = null;
      }
      this.path = [];
      this.goal = goal;
      length = path.length;
      for (i = _i = 0, _len = path.length; _i < _len; i = ++_i) {
        p = path[i];
        if (i < length - 3) {
          avg = (path[i].phi + path[i + 1].phi + path[i + 2].phi) / 3;
          p.phi = avg;
        }
        p.phi = -p.phi;
        this.path.push(p);
      }
      this.cursor = 0;
      this.ctx.clearRect(0, 0, 800, 800);
    },
    reset: function() {
      return this.cursor = 0;
    },
    current: function() {
      return this.path[this.cursor];
    },
    next: function() {
      if (this.cursor < this.path.length) {
        this.cursor++;
        if (this.cursor === this.path.length) {
          return this.reset();
        } else {
          return this.current();
        }
      }
    },
    autopilot: function() {
      var ms;

      if (this.running) {
        this.stopAutopilot();
      } else {
        this.stopAutopilot();
        this.running = true;
        ms = 80;
        this.running = setInterval(function() {
          var conf;

          return conf = waypoints.next();
        }, ms);
      }
    },
    stopAutopilot: function() {
      this.reset();
      clearInterval(this.running);
      return this.running = false;
    },
    isActive: function() {
      return this.path.length > 0 && this.current();
    },
    draw: function() {
      if (!this.isActive()) {
        return;
      }
      this.ctx.clearRect(0, 0, config.canvasWidth, config.canvasHeight);
      this.ctx.save();
      this.ctx.translate(center.x, center.y);
      this.ctx.rotate(delta.theta);
      this.ctx.translate(-center.x - delta.x, -center.y - delta.y);
      this.ctx.strokeStyle = '#000';
      this.drawPath(this.path, 10);
      return this.ctx.restore();
    },
    drawPath: function(path, every, lock) {
      var curr, from, i, to;

      if (every == null) {
        every = 20;
      }
      if (lock == null) {
        lock = false;
      }
      from = 0;
      to = path.length - 1;
      this.ctx.beginPath();
      this.ctx.moveTo(path[from].x, path[from].y);
      i = from;
      if (to - from > 0) {
        while (i < to) {
          curr = path[i];
          this.ctx.lineTo(curr.x, curr.y);
          if (!every || i % every === 0) {
            renderCar(this.ctx, curr);
          }
          i++;
        }
      }
      if (!every) {
        renderCar(this.ctx, path[from]);
      }
      renderCar(this.ctx, this.current());
      renderCar(this.ctx, path[to]);
      return this.ctx.stroke();
    }
  };

  window.trajectory = {
    ctx: ctxTrajectory,
    ctxBuffer: cnvs.create(800, 800),
    tmpPhi: 0,
    tmpX: -1,
    tmpY: -1,
    draw: function() {
      var a, b, color, conf, direction, g, i, multiplier, newConf, nextMove, phi, r, s, steps, _i, _j, _k, _l, _len, _len1, _m, _ref, _ref1;

      conf = truck.conf;
      this.ctxBuffer.clearRect(0, 0, 800, 800);
      this.tmpPhi = u_phi;
      this.tmpX = delta.x;
      this.tmpY = delta.y;
      multiplier = 1;
      steps = 80;
      color = {};
      if (conf.s === 0) {
        direction = [config.speed() * multiplier, -config.speed() * multiplier];
      } else {
        direction = [conf.s * multiplier];
      }
      if (config.showAllFeasiblePaths()) {
        for (_i = 0, _len = direction.length; _i < _len; _i++) {
          s = direction[_i];
          this.ctxBuffer.beginPath();
          for (phi = _j = _ref = truck.U_PHI_MAX[0], _ref1 = truck.U_PHI_MAX[1]; 0.05 > 0 ? _j <= _ref1 : _j >= _ref1; phi = _j += 0.05) {
            newConf = conf;
            for (i = _k = 0; _k <= 20; i = ++_k) {
              r = s < 0 ? 93 : 0;
              g = s < 0 ? 98 : 200;
              b = s < 0 ? 98 : 0;
              a = 0.1;
              this.ctxBuffer.strokeStyle = "rgba(" + r + ", " + g + ", " + b + ", " + a + ")";
              nextMove = truck.legalMoves(newConf, edgeDetection.walls, steps, [s], [phi]);
              if (nextMove.length > 0) {
                newConf = nextMove[0];
              } else {
                break;
              }
              renderCar(this.ctxBuffer, newConf);
            }
          }
          this.ctxBuffer.stroke();
        }
      }
      for (_l = 0, _len1 = direction.length; _l < _len1; _l++) {
        s = direction[_l];
        newConf = conf;
        this.ctxBuffer.beginPath();
        for (i = _m = 0; _m <= 20; i = ++_m) {
          r = s < 0 ? 255 : 255;
          g = s < 0 ? 255 : 255;
          b = s < 0 ? 0 : 0;
          a = 0.4;
          this.ctxBuffer.strokeStyle = "rgba(" + r + ", " + g + ", " + b + ", " + a + ")";
          nextMove = truck.legalMoves(newConf, edgeDetection.walls, steps, [s], [newConf.phi]);
          if (nextMove.length > 0) {
            newConf = nextMove[0];
          } else {
            break;
          }
          renderCar(this.ctxBuffer, newConf);
        }
        this.ctxBuffer.stroke();
      }
      this.ctx.clearRect(0, 0, 800, 800);
      return this.ctx.drawImage(this.ctxBuffer.canvas, 0, 0);
    }
  };

  window.artboard = {
    ctx: ctxDraft,
    drawManualObstacle: function(start, end) {
      this.ctx.beginPath();
      this.ctx.moveTo(start.x, start.y);
      this.ctx.lineTo(end.x, end.y);
      return this.ctx.stroke();
    }
  };

  MODE_GOAL = 'goal';

  MODE_OBS = 'obstacle';

  mode = MODE_GOAL;

  $('#input-mode').on('click', function(e) {
    return mode = e.target.id;
  });

  $('#play').on('click', function(e) {
    return waypoints.autopilot();
  });

  updateDrag = function(dragPosition) {
    ctxDraft.clearRect(0, 0, config.canvasWidth, config.canvasHeight);
    return artboard.drawManualObstacle(startDrag, dragPosition);
  };

  startDrag = null;

  endDrag = null;

  canvas = $(ctxTruck.canvas);

  canvas.on('mousedown touchstart', function(e) {
    document.body.style.cursor = 'crosshair';
    startDrag = this.relMouseCoords(e);
    ctxDraft.strokeStyle = '#333';
    ctxDraft.lineWidth = 5;
    canvas.on('mousemove touchmove', function(e) {
      return updateDrag({
        x: e.offsetX,
        y: e.offsetY
      });
    });
    return e.preventDefault();
  });

  canvas.on('mouseup touchend', function(e) {
    var goal, path, rotation, start;

    document.body.style.cursor = 'default';
    endDrag = this.relMouseCoords(e);
    if (euclid(startDrag, endDrag) > 20) {
      switch (mode) {
        case MODE_OBS:
          app.trigger('obstacle.lidar', [startDrag, endDrag].map(function(e) {
            return relativeToAbsolute(e);
          }));
          break;
        case MODE_GOAL:
          rotation = -Math.atan2(-(startDrag.y - endDrag.y), startDrag.x - endDrag.x);
          if (rotation > 0) {
            rotation -= PI2;
          }
          start = new Conf(center.x, center.y, center.theta, sensorSystem.angle, u_s, u_phi, sensorSystem.angle2);
          goal = new Conf(startDrag.x, startDrag.y, rotation, rotation);
          path = planner.motion(start, goal, edgeDetection.walls).map(function(e) {
            return relativeToAbsolute(e);
          });
          waypoints.init(path, goal);
      }
    }
    ctxDraft.clearRect(0, 0, config.canvasWidth, config.canvasHeight);
    canvas.off('mousemove touchmove');
    return e.preventDefault();
  });

  window.drawManual = function() {
    var conf, ctx, every, i, steps, _i;

    ctx = ctxTruck;
    ctx.clearRect(0, 0, config.canvasWidth, config.canvasHeight);
    conf = center;
    steps = config.steps();
    every = parseInt(steps / 10, 10);
    ctx.beginPath();
    for (i = _i = 0; 0 <= steps ? _i <= steps : _i >= steps; i = 0 <= steps ? ++_i : --_i) {
      if (Math.abs(conf.theta - conf.theta1) > PIHALF) {
        ctx.stroke();
        ctx.strokeStyle = '#f00';
      }
      conf = truck.step(conf.x, conf.y, conf.theta, conf.theta1, config.direction(), config.steer());
      if (!(i % every)) {
        renderCar(ctx, conf);
      }
    }
    ctx.stroke();
    ctx.strokeStyle = '#000';
  };

}).call(this);
